# Лабораторна робота №2

## Варіант №4

### Загальна постановка задач

> 1. Виконати набір вправ. Всі завдання виконати 2 способами:
>    
>    1. з використанням універсальних функцій бібліотеки NumPy;
>    
>    2. за допомогою ітеративних конструкцій (з використанням циклів, спискових включень, тощо);
>    
>    3. для обох випадків підрахувати час виконання скрипту та зробити висновки.
> 
> 2. Розвʼязати систему алгебраїчних рівнянь за допомогою формул Крамера і виконати перевірку за допомогою:
> 
> 3. матричного множення;
> 
> 4. оберненої матриці;
> 
> 5. функції `numpy.linalg.solve()`;
>    
>    Порівняти всі рішення за допомогою функції `numpy.allclose()`.
> 
> 6. Обчислити значення матричного виразу. Виконати 2 способами:
>    
>    1. з використанням універсальних функцій бібліотеки NumPy;
>    
>    2. за допомогою ітеративних конструкцій (з використанням циклів, спискових включень, тощо);
>    
>    3. для обох випадків підрахувати час виконання скрипту та зробити висновки.
>    
>    Порівняти всі рішення за допомогою функції `numpy.allclose()`.

### Завдання №1

#### Вправа №2

> Вводиться число $n$. Розтавити 1 та 0 у шаховому порядку, починаючи з 1 в матриці розміром $n \times n$, використовуючи слайсінг.
> 
> ```python
> In [2] task_2()
>        5
> Out[2] [[0 1 0 1 0]
>         [1 0 1 0 1]
>         [0 1 0 1 0]
>         [1 0 1 0 1]
>         [0 1 0 1 0]]
> ```

#### Вправа №4

> Вводяться числа $n$ i $m$. Вивести масив розміру $n \times m$, в якому у першому ряду (рядок з нулевим індексом) йдуть числа від 0 до $m$-1, а всі інші елементи матриці дорівнюють 0.
> 
> ```python
> In [2] task_4()
>        3 4
> Out[2] [[0 1 2 3]
>         [0 0 0 0]
>         [0 0 0 0]]
> ```

#### Вправа №5

> Вводиться число $n$. Вивести масив розміру $n \times n$, в якому в рядках з парними індексами стоять 1, а в інших - 0.
> 
> ```python
> In [2] task_5()
>        5
> Out[2] [[1 1 1 1 1]
>         [0 0 0 0 0]
>         [1 1 1 1 1]
>         [0 0 0 0 0]
>         [1 1 1 1 1]]
> ```

#### Вправа №8

> З клавіатури вводиться масив. Підрахувати в ньому кількість нульових та ненульових елементів.
> 
> ```python
> In  [2] task_8()
>         3 4 0 9 8 2 4 0 8 4 0
> Out [2] Нулів: 3
>         Не нулів: 8
> ```

#### Вправа №9

> Вводиться число $n$. Створити масив значень від $n$ до 0.
> 
> ```python
> In  [2] task_9()
>         10
> Out [2] [10 9 8 7 6 5 4 3 2 1 0]
> ```

#### Вправа №12

> Створити масив одиниць розміром $n \times n$ та створити в ньому "рамку", що утворюється з 0.
> 
> ```python
> In  [2] task_12()
>         4
> Out [2] [[0. 0. 0. 0.]
>          [0. 1. 1. 0.]
>          [0. 1. 1. 0.]
>          [0. 0. 0. 0.]]
> ```

#### Вправа №13

> Розмістити на полі $8 \times 8$ нулі та одиниці в шаховому порядку, використовуючи функцію повторення (*).
> 
> ```python
> In  [2] task_13()
> Out [2] [[0 1 0 1 0 1 0 1]
>          [1 0 1 0 1 0 1 0]
>          [0 1 0 1 0 1 0 1]
>          [1 0 1 0 1 0 1 0]
>          [0 1 0 1 0 1 0 1]
>          [1 0 1 0 1 0 1 0]
>          [0 1 0 1 0 1 0 1]
>          [1 0 1 0 1 0 1 0]]
> ```

#### Вправа №15

> Заповнити парні стовпчики матриці розміром $n \times n$ одиницями, а непарні - нулями.
> 
> ```python
> In  [2] task_15()
>         5
> Out [2] [[0 1 0 1 0]
>          [0 1 0 1 0]
>          [0 1 0 1 0]
>          [0 1 0 1 0]
>          [0 1 0 1 0]]
> ```

#### Вправа №19

> Згенерувати вектор із $n$ елементів, що рівномірно розміщені на інтервалі $(0, 1)$ - тобто обидва кінці інтервалу не включені. Значення вивести до 3 знаків після коми.
> 
> ```python
> In  [2] task_20()
>         10
> Out [2] [0.091 0.182 0.273 0.364 0.455 0.545 0.636
> 0.727 0.818 0.909]
> ```

### Завдання №2

> Розвʼязати систему алгебраїчних рівнянь за допомогою формул Крамера і виконати перевірку за допомогою:
> 
> a) матричного множення;
> 
> b) оберненої матриці;
> 
> c) функції `numpy.linalg.solve()`
> 
> Порівняти всі рішення за допомогою функції `numpy.allclose()`.
> 
> $$
> \left\{ 
\begin{array}{c}
x_1 + 2x_2 + 3x_3 + 4x_4 = 5 \\
2x_1 + x_2 + 2x_3 + 3x_4 = 1 \\
3x_1 + 2x_2 + x_3 + 2x_4 = 1 \\
4x_1 + 3x_2 + 2x_3 + x_4 = -5   
\end{array}
\right.
> $$

### Завдання №3

> Обчислити значення матричного виразу. Виконати 2 способами:
> 
> а) з використанням універсальних функцій бібліотеки NumPy
> 
> b) за допомогою ітеративних конструкцій (з використанням циклів, спискових включень, тощо).
> 
> c) для обох випадків підрахувати час виконання скрипту та зробити висновок.
> 
> Порівняти всі рішення за допомогою функції `numpy.allclose()`.
> 
> $$
> 2(A - B)(A^2 + B)
> $$
> 
> $$
> \mathrm{де} \; A = \begin{pmatrix} 5 & 1 & 7 \\ -10 & -2 & 1 \\ 0 & 1 & 2 \end{pmatrix}, \; B = \begin{pmatrix} 2 & 4 & 1 \\ 3 & 1 & 0 \\ 7 & 2 & 1 \end{pmatrix}
> $$

### Q&A

##### 1) Яка основна мета створення NumPy?

Основною метою створення NumPy було уникнення неоднозначності при використанні перших бібліотек спеціалізованих обчислень таких як Numeric та Numarray. На даний момент бібліотека використовується як зручний інструмент для роботи з багатовимірними масивами та операціями над ними. 

##### 2) Наведіть основні ознаки, що відрізняє `ndarray` від списків Python.

NumPy `ndarray` кращий за Python `list` у наступних напрямках:

1. Розмір - структура даних NumPy займає менше місця;

2. Продуктивність - структура даних NumPy швидша;

3. Функціональність - структури даних NumPy мають оптимізовані функції, такі як вбудовані операції лінійної алгебри.

##### 3) Перерахуйте основні атрибути `ndarray`.

`ndarray` має наступні атрибути:

- `ndim` - кількість осей (вимірів)

- `shape` - розмір кожної осі

- `size` - загальний розмір масиву

- `dtype` - тип елементів масиву

- `itemsize` - розмір в байтах кожного елементу

- `nbytes` - загальний розмір масиву в байтах

##### 4) Перерахуйте способи створення масивів `ndarray`.

Існує два способи створення масивів:

1) Передача списку Python у функцію `array()`:
   
   ```python
   list = [1, 2, 3]
   
   array = np.array(list)
   ```

2) Або передача списку безпосередньо:
   
   ```python
   array = np.array([1, 2, 3])
   ```

##### 5) Наведіть основні стандартні типи даних NumPy.

Основними типами даних NumPy є:

- bool_ - Boolean (True або False), що зберігається як байт

- int_ - Цілочисельний тип за замовчуванням (такий же,
  
  як int64 або int32)

- intc - Ідентично int (як правило int32 або int64)

- intp - Ціле число, що використовується для індексації
  
  (як правило int32 або int64)

- int8 - Byte (від –128 до 127)

- int16 - Ціле (від –32768 до 32767)

- int32 - Ціле (від –2147483648 до 2147483647)

- int64 - Ціле (від –9223372036854775808 до
  
  9223372036854775807)

- uint8 - Ціле без знаку (від 0 до 255)

- uint16 - Ціле без знаку (від 0 до 65535)

- uint32 - Ціле без знаку (від 0 до 4294967295)

- uint64 - Ціле без знаку (від 0 до 18446744073709551615)

- float_ - Скорочення для float64

- float16 - Число з рухомою крапкою половинної точності,
  знаковий біт, 5-бітна експонента, 10 біт мантиси

- float32 - Число з рухомою крапкою одинарної точності,
  знаковий біт, 8-бітна експонента, 23 біти мантиси

- float64 - Число з рухомою крапкою подвійної точності,
  знаковий біт, 11-бітна експонента, 52 біти
  мантиси

- complex_ - Скорочення для complex128

- complex64 - Комплексне число, представлене двома 32-
  
  бітними числами з рухомою крапкою

- complex128 - Комплексне число, представлене двома 64-
  
  бітними числами з рухомою крапкою

##### 6) Що відбудеться при спробі призначення елементу `a[0] = 4.897` масива `ndarray`, що має `dtype=int`?

float-значення буде приведено до int

##### 7) Що відбудеться при спробі призначення елементу `a[0] = ʼhelloʼ` масива `ndarray`, що має `dtype=int`?

Виникне ValueError

##### 8) В чому відмінність функцій для зміни форми масиву `reshape()` і `resize()`?

Метод `resize()` нічого не повертає, але переформатовує масив, на відміну методу `reshape()`, що тільки повертає представлення масиву, а не сам масив.

##### 9) Наведіть відомі вам способи визначення часу виконання коду.

Існують чотири команди визначенню часу:

- `%time` – час виконання одного оператора;

- `%timeit` – середній час повторного виконання одного
  оператора для більшої точності;

- `%%time` – час виконання всього коду в комірці;

- `%%timeit` – середній час виконання всього коду в комірці.

Також можна використовувати функцію `time()` з модуля `time`, а потім знаходити різницю між двома викликами цієї функції.

##### 10) Перерахуйте арифметичні функції NumPy.

Основні арифметичні функції:

- `np.add` - Додавання (1 + 1 = 2)

- `np.subtract` - Віднімання (2 – 1 = 1)

- `np.negative` - Унарний мінус (–2)

- `np.multiply` - Множення (2 * 2 = 4)

- `np.divide` - Ділення (5 / 2 = 2.5)

- `np.floor_divide` - Цілочисельне ділення (5 / 2 = 2)

- `np.power` - Піднесення у степінь (2 ** 3 = 8)

- `np.mod` - Залишок від ділення (5 / 2 = 1)

##### 11) Наведіть способи виклику агрегатних функцій NumPy.

Основні способи виклику агрегатних функцій:

1) зі вказанням осі (axis)

2) без вказання осі (ахіs)

##### 12) В чому відмінність функцій стандартної бібліотеки Python від відповідних функцій NumPy?

Функції NumPy працюють швидше за відповідні вбудовані функції Python та мають додаткові параметри, що дозволяють виконувати розрахунки за означеними осями.
